{
  "version": 3,
  "sources": ["../../node_modules/@censo-custody/solana-wallet-adapter/src/censocustody.ts"],
  "sourcesContent": ["\nimport {\n    Blockhash, Connection, Message,\n    PublicKey,\n    SIGNATURE_LENGTH_IN_BYTES, Signer, Transaction,\n    TransactionInstruction,\n    TransactionSignature\n} from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport {v4 as uuidv4} from \"uuid\";\nimport { EventEmitter } from \"eventemitter3\";\n\n\ninterface Connected {\n    publicKey: PublicKey;\n}\n\ninterface SendTransaction {\n    identifier: string;\n    signature: TransactionSignature;\n}\n\ninterface SerializableSignaturePubkeyPair {\n    signature: string;\n    pubkey: string;\n}\n\ninterface SignTransaction {\n    identifier: string;\n    signatures: SerializableSignaturePubkeyPair[];\n    feePayer: string;\n    recentBlockhash: Blockhash;\n    message: string;\n}\n\ninterface CensoWalletMessage {\n    type: 'connected' | 'sendTransaction' | 'signTransaction';\n    error?: string;\n    connected?: Connected;\n    sendTransaction?: SendTransaction;\n    signTransaction?: SignTransaction;\n}\n\ninterface TransactionError {\n    message: string\n}\n\ninterface PendingTransactions {\n    [hash: string]: SendTransaction | SignTransaction | null\n}\n\ninterface PendingTransactionErrors {\n    [hash: string]: TransactionError | null\n}\n\ninterface SerializableInstruction {\n    data: string,\n    accountMetas: {address: string, signer: boolean, writable: boolean}[],\n    programId: string\n}\n\nconst DEFAULT_SIGNATURE_BUFFER = Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0)\n\nexport interface SignerOptions {\n    signers?: Signer[];\n}\n\nexport class CensoWallet extends EventEmitter {\n    isLoggedIn: boolean;\n    url = 'https://wallet.censocustody.com';\n    private _pendingTransactions: PendingTransactions;\n    private _pendingTransactionErrors: PendingTransactionErrors;\n    private _timers: number[];\n    private _wallet: Window | null;\n    private _connecting: boolean;\n    private _publicKey: PublicKey | null;\n\n    constructor() {\n        super()\n        this.isLoggedIn = false\n        this._pendingTransactions = {}\n        this._pendingTransactionErrors = {}\n        this._timers = []\n        this._wallet = null;\n        this._connecting = false\n        this._publicKey = null\n\n        window.addEventListener(\"message\", (e) => {\n            this.handleWalletMessage(e.data as CensoWalletMessage)\n        })\n    }\n\n    async connect(url: string | null): Promise<PublicKey> {\n        try {\n            this.url = url || this.url\n            const origin = encodeURIComponent(window.location.origin);\n            const connectUrl = `${this.url}/connect?origin=${origin}`;\n            this._connecting = true\n            this._wallet = window.open(connectUrl, `censo-custody-${origin}`, \"height=900,width=800,menubar=no,status=no,toolbar=no\");\n            if (!this._wallet) {\n                this._connecting = false\n                throw new Error(\"Unable to connect to wallet\")\n            }\n            this._timers.push(window.setInterval(() => {\n                if (this._wallet!.closed) {\n                    this.cleanUp();\n                } else if (this._wallet) {\n                    this._wallet.postMessage({type: 'heartbeat'}, this.url)\n                }\n            }, 100));\n            return new Promise<PublicKey>((resolve, reject) => {\n                const timer = window.setInterval(() => {\n                    if (this.isLoggedIn && this._publicKey) {\n                        this.clearTimer(timer);\n                        resolve(this._publicKey!)\n                    } else if (!this.isLoggedIn && !this._connecting) {\n                        this.clearTimer(timer);\n                        reject(new Error(\"Unable to connect to Censo\"))\n                    }\n                }, 100);\n                this._timers.push(timer)\n            })\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public cleanUp = () => {\n        [...this._timers].forEach(t => this.clearTimer(t));\n        const wallet = this._wallet;\n        if (wallet) {\n            wallet.close()\n        }\n        this._wallet = null\n        this.emit('disconnected')\n    }\n\n    public async signTransaction(transaction: Transaction): Promise<Transaction> {\n        this.verifyCanSignRequests([transaction])\n        try {\n            return this.signOneTransaction(transaction);\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public async signAllTransactions(transactions: Transaction[]): Promise<Transaction[]> {\n        this.verifyCanSignRequests(transactions)\n        try {\n            return this.signMultipleTransactions(transactions);\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public async sendTransaction(\n        transaction: Transaction,\n        connection: Connection,\n        options?: SignerOptions,\n    ): Promise<TransactionSignature> {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new Error(\"Not Connected\");\n\n            const transactionIdentifier = uuidv4()\n            this._pendingTransactions[transactionIdentifier] = null;\n            const signers = options ? options.signers : undefined;\n\n            if (signers && signers!.length > 0) {\n                return new Promise<TransactionSignature>((resolve, reject) => {\n                    this.signOneTransaction(transaction, transactionIdentifier).then(walletTransaction => {\n                        this._pendingTransactions[transactionIdentifier] = null\n                        signers?.length && walletTransaction.partialSign(...signers);\n                        wallet.postMessage({\n                            type: \"sendFinalTransaction\", sendFinalTransaction: {\n                                transactionIdentifier,\n                                signaturePubkeyPairs: walletTransaction.signatures.filter(sp => sp.signature != null).map(sp => {\n                                    return {\n                                        'pubkey': sp.publicKey.toBase58(),\n                                        'signature': sp.signature!.toString('base64')\n                                    }\n                                })\n                            }\n                        }, this.url);\n                        const timer = window.setInterval(() => {\n                            const pendingTransaction = this._pendingTransactions[transactionIdentifier] as SendTransaction\n                            const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier]\n                            if (pendingTransaction != null || pendingTransactionError != null) {\n                                this.clearTimer(timer);\n                                pendingTransaction && resolve(pendingTransaction.signature)\n                                pendingTransactionError && reject(pendingTransactionError)\n                            }\n                        }, 100);\n                        this._timers.push(timer)\n                    }).catch((error) => {\n                        reject(error)\n                        throw error;\n                    })\n                })\n            } else {\n                const instructions = this.instructionsToSerializableInstructions(transaction.instructions)\n                return new Promise<TransactionSignature>((resolve, reject) => {\n                    wallet.postMessage({\n                        type: \"sendTransaction\",\n                        sendTransaction: { instructions, transactionIdentifier }\n                    }, this.url);\n                    const timer = window.setInterval(() => {\n                        const pendingTransaction = this._pendingTransactions[transactionIdentifier] as SendTransaction\n                        const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier]\n                        if (pendingTransaction != null || pendingTransactionError != null) {\n                            this.clearTimer(timer);\n                            pendingTransaction && resolve(pendingTransaction.signature)\n                            pendingTransactionError && reject(pendingTransactionError)\n                        }\n                    }, 100);\n                    this._timers.push(timer)\n                })\n            }\n        } catch (error) {\n            throw error;\n        }\n    }\n\n\n    private clearTimer = (timer: number) => {\n        this._timers = this._timers.filter(t => t != timer)\n        window.clearInterval(timer);\n    }\n\n    private instructionsToSerializableInstructions = (instructions: TransactionInstruction[]): SerializableInstruction[] => instructions.map(i => {\n        return {\n            'programId': i.programId.toBase58(),\n            'accountMetas': i.keys.map(k => {\n                return {\n                    address: k.pubkey.toBase58(),\n                    signer: k.isSigner,\n                    writable: k.isWritable,\n                }\n            }),\n            'data': window.btoa(String.fromCharCode(...i.data)),\n        }\n    })\n\n    private buildTransaction(pendingTransaction: SignTransaction): Transaction {\n        let message = Message.from(Buffer.from(Uint8Array.from(window.atob(pendingTransaction.message!), c => c.charCodeAt(0))))\n        return Transaction.populate(\n            message,\n            Array.from({length: message.header.numRequiredSignatures}, (_v, i) => {\n                let sigPubkeyPair = pendingTransaction.signatures.find(s => s.pubkey == message.accountKeys[i].toBase58())\n                return bs58.encode(sigPubkeyPair\n                    ? Buffer.from(Uint8Array.from(window.atob(sigPubkeyPair.signature), c => c.charCodeAt(0)))\n                    : DEFAULT_SIGNATURE_BUFFER\n                )\n            })\n        )\n    }\n\n    private verifyCanSignRequests(transactions: Transaction[]) {\n        transactions.forEach(transaction => {\n            if (transaction.signatures.some(s => s.signature != null)) {\n                throw new Error(\"Censo does not support this signing mode\")\n            }\n        })\n    }\n\n    private signOneTransaction(transaction: Transaction, transactionIdentifier = uuidv4()): Promise<Transaction> {\n        const wallet = this._wallet;\n        if (!wallet) throw new Error(\"Not Connected\");\n\n        const instructions = this.instructionsToSerializableInstructions(transaction.instructions)\n        this._pendingTransactions[transactionIdentifier] = null;\n        return new Promise<Transaction>((resolve, reject) => {\n            wallet.postMessage({type: \"signTransaction\", signTransaction: { instructions, transactionIdentifier }}, this.url);\n            const timer = window.setInterval(() => {\n                const pendingTransaction = this._pendingTransactions[transactionIdentifier] as SignTransaction\n                const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier]\n                if (pendingTransaction != null || pendingTransactionError != null) {\n                    this.clearTimer(timer)\n                    pendingTransaction && resolve(this.buildTransaction(pendingTransaction))\n                    pendingTransactionError &&  reject(pendingTransactionError)\n                }\n            }, 100);\n            this._timers.push(timer)\n        });\n    }\n\n    private signMultipleTransactions(transactions: Transaction[]): Promise<Transaction[]> {\n        const wallet = this._wallet;\n        if (!wallet) throw new Error(\"Not Connected\");\n\n        const serializedTransactions = transactions.map((t) => {\n            return {\n                instructions: this.instructionsToSerializableInstructions(t.instructions),\n                transactionIdentifier: uuidv4()\n            }\n        })\n        const transactionIdentifiers = serializedTransactions.map((t) => t.transactionIdentifier)\n        transactionIdentifiers.forEach((transactionIdentifier) => this._pendingTransactions[transactionIdentifier] = null)\n        return new Promise<Transaction[]>((resolve, reject) => {\n            wallet.postMessage({type: \"signAllTransactions\", signAllTransactions: {transactions: serializedTransactions}}, this.url);\n            const timer = window.setInterval(() => {\n                const pendingTransactions = transactionIdentifiers.map((txId) => this._pendingTransactions[txId] as SignTransaction)\n                const pendingTransactionErrors = transactionIdentifiers.map((txId) => this._pendingTransactionErrors[txId])\n                if (pendingTransactions.every((t) => t != null)) {\n                    this.clearTimer(timer)\n                    resolve(pendingTransactions.map((pt) => this.buildTransaction(pt)))\n                } else if (pendingTransactionErrors.some((e) => e != null)) {\n                    this.clearTimer(timer)\n                    reject(pendingTransactionErrors.find((e) => e != null))\n                }\n            }, 100);\n            this._timers.push(timer)\n        });\n    }\n\n    private handleWalletMessage = (data: CensoWalletMessage) => {\n        if (data.type == \"connected\") {\n            this._connecting = false;\n            if (!data.error) {\n                this.isLoggedIn = true;\n                if (data.connected?.publicKey) {\n                    this._publicKey = new PublicKey(data.connected.publicKey);\n                }\n            }\n        } else if ([\"sendTransaction\", \"sendFinalTransaction\"].includes(data.type)) {\n            const transactionIdentifier = data.sendTransaction?.identifier\n            if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n                if (data.error) {\n                    this._pendingTransactionErrors[transactionIdentifier] = {message: data.error};\n                } else {\n                    this._pendingTransactions[transactionIdentifier] = data.sendTransaction || null\n                }\n            }\n        } else if (data.type == \"signTransaction\") {\n            const transactionIdentifier = data.signTransaction?.identifier\n            if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n                if (data.error) {\n                    this._pendingTransactionErrors[transactionIdentifier] = {message: data.error}\n                } else {\n                    this._pendingTransactions[transactionIdentifier] = data.signTransaction || null\n                }\n            }\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["bs58"]
}
